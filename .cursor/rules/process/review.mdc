---
description: Code Review Policies and Implementation Procedures in MapStack
globs: 
alwaysApply: false
---
---
title: レビュープロセス
description: MapStackにおけるコードレビューの方針と実施手順
category: process
importance: high
last_updated: 2025-04-13
---

# レビュープロセス

## 1. レビューの目的と原則

### 1.1 レビューの目的
- コード品質の向上と一貫性の確保
- バグや設計上の問題の早期発見
- 知識の共有とチーム全体のスキル向上
- プロジェクト要件との整合性確認
- セキュリティリスクの特定と低減

### 1.2 レビューの基本姿勢
- 建設的かつ敬意のあるフィードバック
- コードではなく問題点に焦点を当てる
- 個人攻撃ではなく、共同作業としてのレビュー
- 絶対的な正解ではなく、より良い方法の提案
- 適切な優先順位付け（重要な問題に集中）

## 2. プルリクエスト作成ガイドライン

### 2.1 PRの準備
- 作業前に最新の `develop` ブランチから派生させる
- 機能単位で小さなPRを心がける（理想は300-500行以内）
- PRを出す前に自己レビューを実施
- コミットは論理的な単位で区切る
- 不要なファイル（`.DS_Store`、`node_modules`など）を含めない

### 2.2 PR説明の書き方

```markdown
## 概要
<!-- 変更内容の簡潔な説明 -->
ユーザープロフィール画面にアバター設定機能を追加

## 関連Issue
<!-- 関連するIssue番号 -->
Closes #42

## 変更内容
<!-- 詳細な変更内容のリスト -->
- アバターアップロード用のUIコンポーネントを追加
- 画像処理サービスとの連携機能を実装
- プロフィール更新APIの拡張
- テストケースの追加

## スクリーンショット
<!-- UI変更の場合はスクリーンショットや動画 -->
![プロフィール画面](mdc:https:/example.com/screenshots/profile.png)

## テスト手順
<!-- テスト方法の説明 -->
1. プロフィール画面に移動
2. 「アバターを変更」ボタンをクリック
3. 画像ファイルを選択してアップロード
4. プロフィールが更新されることを確認

## 追加情報
<!-- レビュアーに伝えたい補足情報 -->
- 画像処理は遅延処理されるため、アップロード直後は古い画像が表示される場合があります
- 現在は1MB以下の画像のみ対応
```

### 2.3 PRのサイズと分割
- **小さいPR**: 1つの機能や修正に集中（推奨）
- **中規模PR**: 関連する複数の小さな変更
- **大規模PR**: やむを得ない場合のみ（リファクタリングなど）、明確な構造と説明が必要

大きな変更の場合、次のように分割を検討してください：
1. データモデルの変更
2. バックエンドロジックの実装
3. フロントエンドUIの実装
4. テストとドキュメントの追加

## 3. レビュープロセスの流れ

### 3.1 レビュー依頼
1. PRを作成し、適切なレビュアーをアサイン
   - 最低2名のレビュアー（コンポーネントオーナー + 1名）
   - バックエンド/フロントエンド双方に影響する場合はそれぞれの担当者
2. Slackの `#code-review` チャンネルでPRリンクを共有
3. レビューの優先度と期限を明示（通常は24時間以内）

### 3.2 レビュー実施
1. コード変更の全体像を把握
2. 詳細コードレビューの実施
3. レビューコメントの記入
   - 明確な問題点の指摘
   - 改善提案がある場合は具体的なコード例
   - 質問や疑問点の明記

### 3.3 レビューへの対応
1. 24時間以内にすべてのコメントに返答
2. 対応が必要なコメントへの修正
3. 対応完了後、レビュアーに再レビューを依頼
4. 議論が必要な場合はコメントで継続、または直接会話

### 3.4 マージプロセス
1. 必要な修正がすべて完了
2. 自動CIチェックがすべて通過
3. 最低2名のレビュアーが承認
4. コンフリクトが解消されていることを確認
5. マージの実行（通常はPR作成者）

## 4. レビュー基準

### 4.1 一般的なチェック項目
- 機能要件を満たしているか
- コーディング規約に従っているか
- テストが十分か（ユニット、統合、E2Eなど）
- エラーハンドリングは適切か
- パフォーマンスに問題はないか
- セキュリティリスクはないか
- 後方互換性は維持されているか
- ドキュメントは更新されているか

### 4.2 フロントエンド固有のチェック
- コンポーネント設計に問題はないか
- 状態管理は効率的か
- UIとUXは一貫しているか
- レスポンシブデザインは適切か
- アクセシビリティに配慮されているか
- 国際化対応に問題はないか
- ブラウザ互換性に問題はないか

```tsx
// 良い例：コンポーネントの責任範囲が明確
const UserProfile: React.FC<UserProfileProps> = ({ user, onUpdate }) => {
  // ...コンポーネントの実装
};

// 問題例：過度に複雑なコンポーネント
const UserDashboard: React.FC = () => {
  // ユーザー情報、タスク管理、通知管理など多くの機能が混在
  // → 複数の小さなコンポーネントに分割すべき
};
```

### 4.3 バックエンド固有のチェック
- APIの設計は適切か
- データベースクエリは最適化されているか
- トランザクション管理は適切か
- バリデーションは十分か
- 認証・認可の処理に問題はないか
- キャッシュ戦略は適切か
- ログ出力は十分か
- 同時実行の問題に対処しているか

```python
# 良い例：スケーラブルなクエリ設計
@router.get("/users", response_model=List[UserResponse])
async def list_users(
    db: Session = Depends(get_db),
    limit: int = 100,
    offset: int = 0,
    status: Optional[str] = None,
):
    return user_service.list_users(db, limit, offset, status)

# 問題例：N+1クエリの問題
@router.get("/users", response_model=List[UserResponse])
async def list_users(db: Session = Depends(get_db)):
    users = db.query(User).all()  # 全ユーザー取得
    
    for user in users:
        # 各ユーザーに対して追加クエリを実行（N+1問題）
        user.posts = db.query(Post).filter(Post.user_id == user.id).all()
    
    return users
```

## 5. フィードバックの質と方法

### 5.1 建設的なフィードバック
- **肯定的な面も指摘**: 良い実装も積極的に評価
- **なぜ**の説明: 問題点だけでなく理由も説明
- **改善案の提示**: 単なる指摘ではなく解決策も提案
- **優先順位の明示**: Mustとniceとなを区別

### 5.2 フィードバックの例

**🔴 問題あり**:
```
この実装ではダメです。パフォーマンスが悪すぎます。
```

**✅ 良い例**:
```
この部分は大量データ処理時にパフォーマンス問題を引き起こす可能性があります。配列全体をループするよりも、
reduce()を使用してO(n)で処理できます。例えば:

```js
const total = items.reduce((sum, item) => sum + item.value, 0);
```

このようにすると、可読性と効率の両方が向上すると思います。
```

### 5.3 レビューコメントの種類
- **必須修正**: 修正なしではマージできない問題
- **提案**: より良い方法の提案だが、実装者の判断に委ねる
- **質問**: 意図や実装の理由を尋ねる
- **褒め言葉**: 良い実装を評価するコメント
- **ナレッジシェア**: 関連する知識や背景の共有

## 6. 効率的なレビュー

### 6.1 レビュー優先順位
1. アーキテクチャと設計の問題
2. セキュリティとパフォーマンスの問題
3. エッジケースとエラーハンドリング
4. コード品質とスタイル
5. ドキュメントとコメント

### 6.2 レビューツールの活用
- GitHub PR機能の活用（サマリー、ファイル毎の表示）
- コードインスペクションツール（SonarQube等）
- 自動コードフォーマット（Prettier, Black）
- CIによる自動テスト結果の確認

### 6.3 レビュー効率化のヒント
- 複雑なロジックには図表やダイアグラムを添付
- 関連するドキュメントへのリンクを追加
- 定期的なペアレビューセッションの実施
- レビューチェックリストの活用

## 7. レビュー文化の育成

### 7.1 チームレビュー文化
- レビューを学習機会としてポジティブに捉える
- 定期的なレビュープラクティスの振り返り
- 新しいチームメンバーへのメンタリング
- レビュースキル向上のためのトレーニング

### 7.2 継続的な改善
- レビュープロセス自体の定期的な評価
- チーム内でのベストプラクティス共有
- 共通の問題パターンを特定と対応
- レビュー効率の向上に向けた取り組み
