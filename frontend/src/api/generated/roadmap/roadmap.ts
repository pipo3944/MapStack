/**
 * Generated by orval v7.8.0 🍺
 * Do not edit manually.
 * MapStack API
 * AI学習プラットフォーム MapStack のバックエンドAPI
 * OpenAPI spec version: 0.1.0
 */
import {
  useMutation,
  useQuery
} from '@tanstack/react-query';
import type {
  DataTag,
  DefinedInitialDataOptions,
  DefinedUseQueryResult,
  MutationFunction,
  QueryClient,
  QueryFunction,
  QueryKey,
  UndefinedInitialDataOptions,
  UseMutationOptions,
  UseMutationResult,
  UseQueryOptions,
  UseQueryResult
} from '@tanstack/react-query';

import type {
  CategoryCreateRequest,
  CategoryDetailResponse,
  CategoryListResponse,
  CategoryUpdateRequest,
  CreateNewVersionEndpointApiV1RoadmapsRoadmapIdNewVersionPostParams,
  HTTPValidationError,
  ReadCategoriesApiV1CategoriesGetParams,
  ReadRoadmapsApiV1RoadmapsGetParams,
  ReadThemesApiV1ThemesGetParams,
  RoadmapCreateRequest,
  RoadmapDetailApiResponse,
  RoadmapEdgeCreateRequest,
  RoadmapEdgeResponse,
  RoadmapEdgeUpdateRequest,
  RoadmapListResponse,
  RoadmapNodeCreateRequest,
  RoadmapNodeResponse,
  RoadmapNodeUpdateRequest,
  RoadmapUpdateRequest,
  RoadmapVersionListResponse,
  ThemeCreateRequest,
  ThemeDetailResponse,
  ThemeListResponse,
  ThemeUpdateRequest
} from '../../model';

import { customInstance } from '../../mutator/custom-instance';




/**
 * カテゴリ一覧を取得する
 * @summary Read Categories
 */
export const readCategoriesApiV1CategoriesGet = (
    params?: ReadCategoriesApiV1CategoriesGetParams,
 signal?: AbortSignal
) => {
      
      
      return customInstance<CategoryListResponse>(
      {url: `/api/v1/categories/`, method: 'GET',
        params, signal
    },
      );
    }
  

export const getReadCategoriesApiV1CategoriesGetQueryKey = (params?: ReadCategoriesApiV1CategoriesGetParams,) => {
    return [`/api/v1/categories/`, ...(params ? [params]: [])] as const;
    }

    
export const getReadCategoriesApiV1CategoriesGetQueryOptions = <TData = Awaited<ReturnType<typeof readCategoriesApiV1CategoriesGet>>, TError = HTTPValidationError>(params?: ReadCategoriesApiV1CategoriesGetParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof readCategoriesApiV1CategoriesGet>>, TError, TData>>, }
) => {

const {query: queryOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getReadCategoriesApiV1CategoriesGetQueryKey(params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof readCategoriesApiV1CategoriesGet>>> = ({ signal }) => readCategoriesApiV1CategoriesGet(params, signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof readCategoriesApiV1CategoriesGet>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type ReadCategoriesApiV1CategoriesGetQueryResult = NonNullable<Awaited<ReturnType<typeof readCategoriesApiV1CategoriesGet>>>
export type ReadCategoriesApiV1CategoriesGetQueryError = HTTPValidationError


export function useReadCategoriesApiV1CategoriesGet<TData = Awaited<ReturnType<typeof readCategoriesApiV1CategoriesGet>>, TError = HTTPValidationError>(
 params: undefined |  ReadCategoriesApiV1CategoriesGetParams, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof readCategoriesApiV1CategoriesGet>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof readCategoriesApiV1CategoriesGet>>,
          TError,
          Awaited<ReturnType<typeof readCategoriesApiV1CategoriesGet>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useReadCategoriesApiV1CategoriesGet<TData = Awaited<ReturnType<typeof readCategoriesApiV1CategoriesGet>>, TError = HTTPValidationError>(
 params?: ReadCategoriesApiV1CategoriesGetParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof readCategoriesApiV1CategoriesGet>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof readCategoriesApiV1CategoriesGet>>,
          TError,
          Awaited<ReturnType<typeof readCategoriesApiV1CategoriesGet>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useReadCategoriesApiV1CategoriesGet<TData = Awaited<ReturnType<typeof readCategoriesApiV1CategoriesGet>>, TError = HTTPValidationError>(
 params?: ReadCategoriesApiV1CategoriesGetParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof readCategoriesApiV1CategoriesGet>>, TError, TData>>, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary Read Categories
 */

export function useReadCategoriesApiV1CategoriesGet<TData = Awaited<ReturnType<typeof readCategoriesApiV1CategoriesGet>>, TError = HTTPValidationError>(
 params?: ReadCategoriesApiV1CategoriesGetParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof readCategoriesApiV1CategoriesGet>>, TError, TData>>, }
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getReadCategoriesApiV1CategoriesGetQueryOptions(params,options)

  const query = useQuery(queryOptions , queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



/**
 * 新しいカテゴリを作成する
 * @summary Create Category Endpoint
 */
export const createCategoryEndpointApiV1CategoriesPost = (
    categoryCreateRequest: CategoryCreateRequest,
 signal?: AbortSignal
) => {
      
      
      return customInstance<CategoryDetailResponse>(
      {url: `/api/v1/categories/`, method: 'POST',
      headers: {'Content-Type': 'application/json', },
      data: categoryCreateRequest, signal
    },
      );
    }
  


export const getCreateCategoryEndpointApiV1CategoriesPostMutationOptions = <TError = HTTPValidationError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof createCategoryEndpointApiV1CategoriesPost>>, TError,{data: CategoryCreateRequest}, TContext>, }
): UseMutationOptions<Awaited<ReturnType<typeof createCategoryEndpointApiV1CategoriesPost>>, TError,{data: CategoryCreateRequest}, TContext> => {
    
const mutationKey = ['createCategoryEndpointApiV1CategoriesPost'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof createCategoryEndpointApiV1CategoriesPost>>, {data: CategoryCreateRequest}> = (props) => {
          const {data} = props ?? {};

          return  createCategoryEndpointApiV1CategoriesPost(data,)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type CreateCategoryEndpointApiV1CategoriesPostMutationResult = NonNullable<Awaited<ReturnType<typeof createCategoryEndpointApiV1CategoriesPost>>>
    export type CreateCategoryEndpointApiV1CategoriesPostMutationBody = CategoryCreateRequest
    export type CreateCategoryEndpointApiV1CategoriesPostMutationError = HTTPValidationError

    /**
 * @summary Create Category Endpoint
 */
export const useCreateCategoryEndpointApiV1CategoriesPost = <TError = HTTPValidationError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof createCategoryEndpointApiV1CategoriesPost>>, TError,{data: CategoryCreateRequest}, TContext>, }
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof createCategoryEndpointApiV1CategoriesPost>>,
        TError,
        {data: CategoryCreateRequest},
        TContext
      > => {

      const mutationOptions = getCreateCategoryEndpointApiV1CategoriesPostMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    /**
 * 特定のカテゴリを取得する
 * @summary Read Category
 */
export const readCategoryApiV1CategoriesCategoryIdGet = (
    categoryId: string,
 signal?: AbortSignal
) => {
      
      
      return customInstance<CategoryDetailResponse>(
      {url: `/api/v1/categories/${categoryId}`, method: 'GET', signal
    },
      );
    }
  

export const getReadCategoryApiV1CategoriesCategoryIdGetQueryKey = (categoryId: string,) => {
    return [`/api/v1/categories/${categoryId}`] as const;
    }

    
export const getReadCategoryApiV1CategoriesCategoryIdGetQueryOptions = <TData = Awaited<ReturnType<typeof readCategoryApiV1CategoriesCategoryIdGet>>, TError = HTTPValidationError>(categoryId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof readCategoryApiV1CategoriesCategoryIdGet>>, TError, TData>>, }
) => {

const {query: queryOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getReadCategoryApiV1CategoriesCategoryIdGetQueryKey(categoryId);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof readCategoryApiV1CategoriesCategoryIdGet>>> = ({ signal }) => readCategoryApiV1CategoriesCategoryIdGet(categoryId, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(categoryId), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof readCategoryApiV1CategoriesCategoryIdGet>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type ReadCategoryApiV1CategoriesCategoryIdGetQueryResult = NonNullable<Awaited<ReturnType<typeof readCategoryApiV1CategoriesCategoryIdGet>>>
export type ReadCategoryApiV1CategoriesCategoryIdGetQueryError = HTTPValidationError


export function useReadCategoryApiV1CategoriesCategoryIdGet<TData = Awaited<ReturnType<typeof readCategoryApiV1CategoriesCategoryIdGet>>, TError = HTTPValidationError>(
 categoryId: string, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof readCategoryApiV1CategoriesCategoryIdGet>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof readCategoryApiV1CategoriesCategoryIdGet>>,
          TError,
          Awaited<ReturnType<typeof readCategoryApiV1CategoriesCategoryIdGet>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useReadCategoryApiV1CategoriesCategoryIdGet<TData = Awaited<ReturnType<typeof readCategoryApiV1CategoriesCategoryIdGet>>, TError = HTTPValidationError>(
 categoryId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof readCategoryApiV1CategoriesCategoryIdGet>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof readCategoryApiV1CategoriesCategoryIdGet>>,
          TError,
          Awaited<ReturnType<typeof readCategoryApiV1CategoriesCategoryIdGet>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useReadCategoryApiV1CategoriesCategoryIdGet<TData = Awaited<ReturnType<typeof readCategoryApiV1CategoriesCategoryIdGet>>, TError = HTTPValidationError>(
 categoryId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof readCategoryApiV1CategoriesCategoryIdGet>>, TError, TData>>, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary Read Category
 */

export function useReadCategoryApiV1CategoriesCategoryIdGet<TData = Awaited<ReturnType<typeof readCategoryApiV1CategoriesCategoryIdGet>>, TError = HTTPValidationError>(
 categoryId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof readCategoryApiV1CategoriesCategoryIdGet>>, TError, TData>>, }
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getReadCategoryApiV1CategoriesCategoryIdGetQueryOptions(categoryId,options)

  const query = useQuery(queryOptions , queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



/**
 * 特定のカテゴリを更新する
 * @summary Update Category Endpoint
 */
export const updateCategoryEndpointApiV1CategoriesCategoryIdPut = (
    categoryId: string,
    categoryUpdateRequest: CategoryUpdateRequest,
 ) => {
      
      
      return customInstance<CategoryDetailResponse>(
      {url: `/api/v1/categories/${categoryId}`, method: 'PUT',
      headers: {'Content-Type': 'application/json', },
      data: categoryUpdateRequest
    },
      );
    }
  


export const getUpdateCategoryEndpointApiV1CategoriesCategoryIdPutMutationOptions = <TError = HTTPValidationError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof updateCategoryEndpointApiV1CategoriesCategoryIdPut>>, TError,{categoryId: string;data: CategoryUpdateRequest}, TContext>, }
): UseMutationOptions<Awaited<ReturnType<typeof updateCategoryEndpointApiV1CategoriesCategoryIdPut>>, TError,{categoryId: string;data: CategoryUpdateRequest}, TContext> => {
    
const mutationKey = ['updateCategoryEndpointApiV1CategoriesCategoryIdPut'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof updateCategoryEndpointApiV1CategoriesCategoryIdPut>>, {categoryId: string;data: CategoryUpdateRequest}> = (props) => {
          const {categoryId,data} = props ?? {};

          return  updateCategoryEndpointApiV1CategoriesCategoryIdPut(categoryId,data,)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type UpdateCategoryEndpointApiV1CategoriesCategoryIdPutMutationResult = NonNullable<Awaited<ReturnType<typeof updateCategoryEndpointApiV1CategoriesCategoryIdPut>>>
    export type UpdateCategoryEndpointApiV1CategoriesCategoryIdPutMutationBody = CategoryUpdateRequest
    export type UpdateCategoryEndpointApiV1CategoriesCategoryIdPutMutationError = HTTPValidationError

    /**
 * @summary Update Category Endpoint
 */
export const useUpdateCategoryEndpointApiV1CategoriesCategoryIdPut = <TError = HTTPValidationError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof updateCategoryEndpointApiV1CategoriesCategoryIdPut>>, TError,{categoryId: string;data: CategoryUpdateRequest}, TContext>, }
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof updateCategoryEndpointApiV1CategoriesCategoryIdPut>>,
        TError,
        {categoryId: string;data: CategoryUpdateRequest},
        TContext
      > => {

      const mutationOptions = getUpdateCategoryEndpointApiV1CategoriesCategoryIdPutMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    /**
 * 特定のカテゴリを削除する
 * @summary Delete Category Endpoint
 */
export const deleteCategoryEndpointApiV1CategoriesCategoryIdDelete = (
    categoryId: string,
 ) => {
      
      
      return customInstance<void>(
      {url: `/api/v1/categories/${categoryId}`, method: 'DELETE'
    },
      );
    }
  


export const getDeleteCategoryEndpointApiV1CategoriesCategoryIdDeleteMutationOptions = <TError = HTTPValidationError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof deleteCategoryEndpointApiV1CategoriesCategoryIdDelete>>, TError,{categoryId: string}, TContext>, }
): UseMutationOptions<Awaited<ReturnType<typeof deleteCategoryEndpointApiV1CategoriesCategoryIdDelete>>, TError,{categoryId: string}, TContext> => {
    
const mutationKey = ['deleteCategoryEndpointApiV1CategoriesCategoryIdDelete'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof deleteCategoryEndpointApiV1CategoriesCategoryIdDelete>>, {categoryId: string}> = (props) => {
          const {categoryId} = props ?? {};

          return  deleteCategoryEndpointApiV1CategoriesCategoryIdDelete(categoryId,)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type DeleteCategoryEndpointApiV1CategoriesCategoryIdDeleteMutationResult = NonNullable<Awaited<ReturnType<typeof deleteCategoryEndpointApiV1CategoriesCategoryIdDelete>>>
    
    export type DeleteCategoryEndpointApiV1CategoriesCategoryIdDeleteMutationError = HTTPValidationError

    /**
 * @summary Delete Category Endpoint
 */
export const useDeleteCategoryEndpointApiV1CategoriesCategoryIdDelete = <TError = HTTPValidationError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof deleteCategoryEndpointApiV1CategoriesCategoryIdDelete>>, TError,{categoryId: string}, TContext>, }
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof deleteCategoryEndpointApiV1CategoriesCategoryIdDelete>>,
        TError,
        {categoryId: string},
        TContext
      > => {

      const mutationOptions = getDeleteCategoryEndpointApiV1CategoriesCategoryIdDeleteMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    /**
 * テーマ一覧を取得する
 * @summary Read Themes
 */
export const readThemesApiV1ThemesGet = (
    params?: ReadThemesApiV1ThemesGetParams,
 signal?: AbortSignal
) => {
      
      
      return customInstance<ThemeListResponse>(
      {url: `/api/v1/themes/`, method: 'GET',
        params, signal
    },
      );
    }
  

export const getReadThemesApiV1ThemesGetQueryKey = (params?: ReadThemesApiV1ThemesGetParams,) => {
    return [`/api/v1/themes/`, ...(params ? [params]: [])] as const;
    }

    
export const getReadThemesApiV1ThemesGetQueryOptions = <TData = Awaited<ReturnType<typeof readThemesApiV1ThemesGet>>, TError = HTTPValidationError>(params?: ReadThemesApiV1ThemesGetParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof readThemesApiV1ThemesGet>>, TError, TData>>, }
) => {

const {query: queryOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getReadThemesApiV1ThemesGetQueryKey(params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof readThemesApiV1ThemesGet>>> = ({ signal }) => readThemesApiV1ThemesGet(params, signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof readThemesApiV1ThemesGet>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type ReadThemesApiV1ThemesGetQueryResult = NonNullable<Awaited<ReturnType<typeof readThemesApiV1ThemesGet>>>
export type ReadThemesApiV1ThemesGetQueryError = HTTPValidationError


export function useReadThemesApiV1ThemesGet<TData = Awaited<ReturnType<typeof readThemesApiV1ThemesGet>>, TError = HTTPValidationError>(
 params: undefined |  ReadThemesApiV1ThemesGetParams, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof readThemesApiV1ThemesGet>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof readThemesApiV1ThemesGet>>,
          TError,
          Awaited<ReturnType<typeof readThemesApiV1ThemesGet>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useReadThemesApiV1ThemesGet<TData = Awaited<ReturnType<typeof readThemesApiV1ThemesGet>>, TError = HTTPValidationError>(
 params?: ReadThemesApiV1ThemesGetParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof readThemesApiV1ThemesGet>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof readThemesApiV1ThemesGet>>,
          TError,
          Awaited<ReturnType<typeof readThemesApiV1ThemesGet>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useReadThemesApiV1ThemesGet<TData = Awaited<ReturnType<typeof readThemesApiV1ThemesGet>>, TError = HTTPValidationError>(
 params?: ReadThemesApiV1ThemesGetParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof readThemesApiV1ThemesGet>>, TError, TData>>, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary Read Themes
 */

export function useReadThemesApiV1ThemesGet<TData = Awaited<ReturnType<typeof readThemesApiV1ThemesGet>>, TError = HTTPValidationError>(
 params?: ReadThemesApiV1ThemesGetParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof readThemesApiV1ThemesGet>>, TError, TData>>, }
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getReadThemesApiV1ThemesGetQueryOptions(params,options)

  const query = useQuery(queryOptions , queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



/**
 * 新しいテーマを作成する
 * @summary Create Theme Endpoint
 */
export const createThemeEndpointApiV1ThemesPost = (
    themeCreateRequest: ThemeCreateRequest,
 signal?: AbortSignal
) => {
      
      
      return customInstance<ThemeDetailResponse>(
      {url: `/api/v1/themes/`, method: 'POST',
      headers: {'Content-Type': 'application/json', },
      data: themeCreateRequest, signal
    },
      );
    }
  


export const getCreateThemeEndpointApiV1ThemesPostMutationOptions = <TError = HTTPValidationError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof createThemeEndpointApiV1ThemesPost>>, TError,{data: ThemeCreateRequest}, TContext>, }
): UseMutationOptions<Awaited<ReturnType<typeof createThemeEndpointApiV1ThemesPost>>, TError,{data: ThemeCreateRequest}, TContext> => {
    
const mutationKey = ['createThemeEndpointApiV1ThemesPost'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof createThemeEndpointApiV1ThemesPost>>, {data: ThemeCreateRequest}> = (props) => {
          const {data} = props ?? {};

          return  createThemeEndpointApiV1ThemesPost(data,)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type CreateThemeEndpointApiV1ThemesPostMutationResult = NonNullable<Awaited<ReturnType<typeof createThemeEndpointApiV1ThemesPost>>>
    export type CreateThemeEndpointApiV1ThemesPostMutationBody = ThemeCreateRequest
    export type CreateThemeEndpointApiV1ThemesPostMutationError = HTTPValidationError

    /**
 * @summary Create Theme Endpoint
 */
export const useCreateThemeEndpointApiV1ThemesPost = <TError = HTTPValidationError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof createThemeEndpointApiV1ThemesPost>>, TError,{data: ThemeCreateRequest}, TContext>, }
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof createThemeEndpointApiV1ThemesPost>>,
        TError,
        {data: ThemeCreateRequest},
        TContext
      > => {

      const mutationOptions = getCreateThemeEndpointApiV1ThemesPostMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    /**
 * 特定のテーマを取得する
 * @summary Read Theme
 */
export const readThemeApiV1ThemesThemeIdGet = (
    themeId: string,
 signal?: AbortSignal
) => {
      
      
      return customInstance<ThemeDetailResponse>(
      {url: `/api/v1/themes/${themeId}`, method: 'GET', signal
    },
      );
    }
  

export const getReadThemeApiV1ThemesThemeIdGetQueryKey = (themeId: string,) => {
    return [`/api/v1/themes/${themeId}`] as const;
    }

    
export const getReadThemeApiV1ThemesThemeIdGetQueryOptions = <TData = Awaited<ReturnType<typeof readThemeApiV1ThemesThemeIdGet>>, TError = HTTPValidationError>(themeId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof readThemeApiV1ThemesThemeIdGet>>, TError, TData>>, }
) => {

const {query: queryOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getReadThemeApiV1ThemesThemeIdGetQueryKey(themeId);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof readThemeApiV1ThemesThemeIdGet>>> = ({ signal }) => readThemeApiV1ThemesThemeIdGet(themeId, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(themeId), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof readThemeApiV1ThemesThemeIdGet>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type ReadThemeApiV1ThemesThemeIdGetQueryResult = NonNullable<Awaited<ReturnType<typeof readThemeApiV1ThemesThemeIdGet>>>
export type ReadThemeApiV1ThemesThemeIdGetQueryError = HTTPValidationError


export function useReadThemeApiV1ThemesThemeIdGet<TData = Awaited<ReturnType<typeof readThemeApiV1ThemesThemeIdGet>>, TError = HTTPValidationError>(
 themeId: string, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof readThemeApiV1ThemesThemeIdGet>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof readThemeApiV1ThemesThemeIdGet>>,
          TError,
          Awaited<ReturnType<typeof readThemeApiV1ThemesThemeIdGet>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useReadThemeApiV1ThemesThemeIdGet<TData = Awaited<ReturnType<typeof readThemeApiV1ThemesThemeIdGet>>, TError = HTTPValidationError>(
 themeId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof readThemeApiV1ThemesThemeIdGet>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof readThemeApiV1ThemesThemeIdGet>>,
          TError,
          Awaited<ReturnType<typeof readThemeApiV1ThemesThemeIdGet>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useReadThemeApiV1ThemesThemeIdGet<TData = Awaited<ReturnType<typeof readThemeApiV1ThemesThemeIdGet>>, TError = HTTPValidationError>(
 themeId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof readThemeApiV1ThemesThemeIdGet>>, TError, TData>>, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary Read Theme
 */

export function useReadThemeApiV1ThemesThemeIdGet<TData = Awaited<ReturnType<typeof readThemeApiV1ThemesThemeIdGet>>, TError = HTTPValidationError>(
 themeId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof readThemeApiV1ThemesThemeIdGet>>, TError, TData>>, }
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getReadThemeApiV1ThemesThemeIdGetQueryOptions(themeId,options)

  const query = useQuery(queryOptions , queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



/**
 * 特定のテーマを更新する
 * @summary Update Theme Endpoint
 */
export const updateThemeEndpointApiV1ThemesThemeIdPut = (
    themeId: string,
    themeUpdateRequest: ThemeUpdateRequest,
 ) => {
      
      
      return customInstance<ThemeDetailResponse>(
      {url: `/api/v1/themes/${themeId}`, method: 'PUT',
      headers: {'Content-Type': 'application/json', },
      data: themeUpdateRequest
    },
      );
    }
  


export const getUpdateThemeEndpointApiV1ThemesThemeIdPutMutationOptions = <TError = HTTPValidationError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof updateThemeEndpointApiV1ThemesThemeIdPut>>, TError,{themeId: string;data: ThemeUpdateRequest}, TContext>, }
): UseMutationOptions<Awaited<ReturnType<typeof updateThemeEndpointApiV1ThemesThemeIdPut>>, TError,{themeId: string;data: ThemeUpdateRequest}, TContext> => {
    
const mutationKey = ['updateThemeEndpointApiV1ThemesThemeIdPut'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof updateThemeEndpointApiV1ThemesThemeIdPut>>, {themeId: string;data: ThemeUpdateRequest}> = (props) => {
          const {themeId,data} = props ?? {};

          return  updateThemeEndpointApiV1ThemesThemeIdPut(themeId,data,)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type UpdateThemeEndpointApiV1ThemesThemeIdPutMutationResult = NonNullable<Awaited<ReturnType<typeof updateThemeEndpointApiV1ThemesThemeIdPut>>>
    export type UpdateThemeEndpointApiV1ThemesThemeIdPutMutationBody = ThemeUpdateRequest
    export type UpdateThemeEndpointApiV1ThemesThemeIdPutMutationError = HTTPValidationError

    /**
 * @summary Update Theme Endpoint
 */
export const useUpdateThemeEndpointApiV1ThemesThemeIdPut = <TError = HTTPValidationError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof updateThemeEndpointApiV1ThemesThemeIdPut>>, TError,{themeId: string;data: ThemeUpdateRequest}, TContext>, }
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof updateThemeEndpointApiV1ThemesThemeIdPut>>,
        TError,
        {themeId: string;data: ThemeUpdateRequest},
        TContext
      > => {

      const mutationOptions = getUpdateThemeEndpointApiV1ThemesThemeIdPutMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    /**
 * 特定のテーマを削除する
 * @summary Delete Theme Endpoint
 */
export const deleteThemeEndpointApiV1ThemesThemeIdDelete = (
    themeId: string,
 ) => {
      
      
      return customInstance<void>(
      {url: `/api/v1/themes/${themeId}`, method: 'DELETE'
    },
      );
    }
  


export const getDeleteThemeEndpointApiV1ThemesThemeIdDeleteMutationOptions = <TError = HTTPValidationError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof deleteThemeEndpointApiV1ThemesThemeIdDelete>>, TError,{themeId: string}, TContext>, }
): UseMutationOptions<Awaited<ReturnType<typeof deleteThemeEndpointApiV1ThemesThemeIdDelete>>, TError,{themeId: string}, TContext> => {
    
const mutationKey = ['deleteThemeEndpointApiV1ThemesThemeIdDelete'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof deleteThemeEndpointApiV1ThemesThemeIdDelete>>, {themeId: string}> = (props) => {
          const {themeId} = props ?? {};

          return  deleteThemeEndpointApiV1ThemesThemeIdDelete(themeId,)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type DeleteThemeEndpointApiV1ThemesThemeIdDeleteMutationResult = NonNullable<Awaited<ReturnType<typeof deleteThemeEndpointApiV1ThemesThemeIdDelete>>>
    
    export type DeleteThemeEndpointApiV1ThemesThemeIdDeleteMutationError = HTTPValidationError

    /**
 * @summary Delete Theme Endpoint
 */
export const useDeleteThemeEndpointApiV1ThemesThemeIdDelete = <TError = HTTPValidationError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof deleteThemeEndpointApiV1ThemesThemeIdDelete>>, TError,{themeId: string}, TContext>, }
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof deleteThemeEndpointApiV1ThemesThemeIdDelete>>,
        TError,
        {themeId: string},
        TContext
      > => {

      const mutationOptions = getDeleteThemeEndpointApiV1ThemesThemeIdDeleteMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    /**
 * ロードマップ一覧を取得する
 * @summary Read Roadmaps
 */
export const readRoadmapsApiV1RoadmapsGet = (
    params?: ReadRoadmapsApiV1RoadmapsGetParams,
 signal?: AbortSignal
) => {
      
      
      return customInstance<RoadmapListResponse>(
      {url: `/api/v1/roadmaps/`, method: 'GET',
        params, signal
    },
      );
    }
  

export const getReadRoadmapsApiV1RoadmapsGetQueryKey = (params?: ReadRoadmapsApiV1RoadmapsGetParams,) => {
    return [`/api/v1/roadmaps/`, ...(params ? [params]: [])] as const;
    }

    
export const getReadRoadmapsApiV1RoadmapsGetQueryOptions = <TData = Awaited<ReturnType<typeof readRoadmapsApiV1RoadmapsGet>>, TError = HTTPValidationError>(params?: ReadRoadmapsApiV1RoadmapsGetParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof readRoadmapsApiV1RoadmapsGet>>, TError, TData>>, }
) => {

const {query: queryOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getReadRoadmapsApiV1RoadmapsGetQueryKey(params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof readRoadmapsApiV1RoadmapsGet>>> = ({ signal }) => readRoadmapsApiV1RoadmapsGet(params, signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof readRoadmapsApiV1RoadmapsGet>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type ReadRoadmapsApiV1RoadmapsGetQueryResult = NonNullable<Awaited<ReturnType<typeof readRoadmapsApiV1RoadmapsGet>>>
export type ReadRoadmapsApiV1RoadmapsGetQueryError = HTTPValidationError


export function useReadRoadmapsApiV1RoadmapsGet<TData = Awaited<ReturnType<typeof readRoadmapsApiV1RoadmapsGet>>, TError = HTTPValidationError>(
 params: undefined |  ReadRoadmapsApiV1RoadmapsGetParams, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof readRoadmapsApiV1RoadmapsGet>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof readRoadmapsApiV1RoadmapsGet>>,
          TError,
          Awaited<ReturnType<typeof readRoadmapsApiV1RoadmapsGet>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useReadRoadmapsApiV1RoadmapsGet<TData = Awaited<ReturnType<typeof readRoadmapsApiV1RoadmapsGet>>, TError = HTTPValidationError>(
 params?: ReadRoadmapsApiV1RoadmapsGetParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof readRoadmapsApiV1RoadmapsGet>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof readRoadmapsApiV1RoadmapsGet>>,
          TError,
          Awaited<ReturnType<typeof readRoadmapsApiV1RoadmapsGet>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useReadRoadmapsApiV1RoadmapsGet<TData = Awaited<ReturnType<typeof readRoadmapsApiV1RoadmapsGet>>, TError = HTTPValidationError>(
 params?: ReadRoadmapsApiV1RoadmapsGetParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof readRoadmapsApiV1RoadmapsGet>>, TError, TData>>, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary Read Roadmaps
 */

export function useReadRoadmapsApiV1RoadmapsGet<TData = Awaited<ReturnType<typeof readRoadmapsApiV1RoadmapsGet>>, TError = HTTPValidationError>(
 params?: ReadRoadmapsApiV1RoadmapsGetParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof readRoadmapsApiV1RoadmapsGet>>, TError, TData>>, }
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getReadRoadmapsApiV1RoadmapsGetQueryOptions(params,options)

  const query = useQuery(queryOptions , queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



/**
 * 新しいロードマップを作成する
 * @summary Create Roadmap Endpoint
 */
export const createRoadmapEndpointApiV1RoadmapsPost = (
    roadmapCreateRequest: RoadmapCreateRequest,
 signal?: AbortSignal
) => {
      
      
      return customInstance<RoadmapDetailApiResponse>(
      {url: `/api/v1/roadmaps/`, method: 'POST',
      headers: {'Content-Type': 'application/json', },
      data: roadmapCreateRequest, signal
    },
      );
    }
  


export const getCreateRoadmapEndpointApiV1RoadmapsPostMutationOptions = <TError = HTTPValidationError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof createRoadmapEndpointApiV1RoadmapsPost>>, TError,{data: RoadmapCreateRequest}, TContext>, }
): UseMutationOptions<Awaited<ReturnType<typeof createRoadmapEndpointApiV1RoadmapsPost>>, TError,{data: RoadmapCreateRequest}, TContext> => {
    
const mutationKey = ['createRoadmapEndpointApiV1RoadmapsPost'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof createRoadmapEndpointApiV1RoadmapsPost>>, {data: RoadmapCreateRequest}> = (props) => {
          const {data} = props ?? {};

          return  createRoadmapEndpointApiV1RoadmapsPost(data,)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type CreateRoadmapEndpointApiV1RoadmapsPostMutationResult = NonNullable<Awaited<ReturnType<typeof createRoadmapEndpointApiV1RoadmapsPost>>>
    export type CreateRoadmapEndpointApiV1RoadmapsPostMutationBody = RoadmapCreateRequest
    export type CreateRoadmapEndpointApiV1RoadmapsPostMutationError = HTTPValidationError

    /**
 * @summary Create Roadmap Endpoint
 */
export const useCreateRoadmapEndpointApiV1RoadmapsPost = <TError = HTTPValidationError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof createRoadmapEndpointApiV1RoadmapsPost>>, TError,{data: RoadmapCreateRequest}, TContext>, }
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof createRoadmapEndpointApiV1RoadmapsPost>>,
        TError,
        {data: RoadmapCreateRequest},
        TContext
      > => {

      const mutationOptions = getCreateRoadmapEndpointApiV1RoadmapsPostMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    /**
 * 特定のロードマップを取得する
 * @summary Read Roadmap
 */
export const readRoadmapApiV1RoadmapsRoadmapIdGet = (
    roadmapId: string,
 signal?: AbortSignal
) => {
      
      
      return customInstance<RoadmapDetailApiResponse>(
      {url: `/api/v1/roadmaps/${roadmapId}`, method: 'GET', signal
    },
      );
    }
  

export const getReadRoadmapApiV1RoadmapsRoadmapIdGetQueryKey = (roadmapId: string,) => {
    return [`/api/v1/roadmaps/${roadmapId}`] as const;
    }

    
export const getReadRoadmapApiV1RoadmapsRoadmapIdGetQueryOptions = <TData = Awaited<ReturnType<typeof readRoadmapApiV1RoadmapsRoadmapIdGet>>, TError = HTTPValidationError>(roadmapId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof readRoadmapApiV1RoadmapsRoadmapIdGet>>, TError, TData>>, }
) => {

const {query: queryOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getReadRoadmapApiV1RoadmapsRoadmapIdGetQueryKey(roadmapId);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof readRoadmapApiV1RoadmapsRoadmapIdGet>>> = ({ signal }) => readRoadmapApiV1RoadmapsRoadmapIdGet(roadmapId, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(roadmapId), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof readRoadmapApiV1RoadmapsRoadmapIdGet>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type ReadRoadmapApiV1RoadmapsRoadmapIdGetQueryResult = NonNullable<Awaited<ReturnType<typeof readRoadmapApiV1RoadmapsRoadmapIdGet>>>
export type ReadRoadmapApiV1RoadmapsRoadmapIdGetQueryError = HTTPValidationError


export function useReadRoadmapApiV1RoadmapsRoadmapIdGet<TData = Awaited<ReturnType<typeof readRoadmapApiV1RoadmapsRoadmapIdGet>>, TError = HTTPValidationError>(
 roadmapId: string, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof readRoadmapApiV1RoadmapsRoadmapIdGet>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof readRoadmapApiV1RoadmapsRoadmapIdGet>>,
          TError,
          Awaited<ReturnType<typeof readRoadmapApiV1RoadmapsRoadmapIdGet>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useReadRoadmapApiV1RoadmapsRoadmapIdGet<TData = Awaited<ReturnType<typeof readRoadmapApiV1RoadmapsRoadmapIdGet>>, TError = HTTPValidationError>(
 roadmapId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof readRoadmapApiV1RoadmapsRoadmapIdGet>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof readRoadmapApiV1RoadmapsRoadmapIdGet>>,
          TError,
          Awaited<ReturnType<typeof readRoadmapApiV1RoadmapsRoadmapIdGet>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useReadRoadmapApiV1RoadmapsRoadmapIdGet<TData = Awaited<ReturnType<typeof readRoadmapApiV1RoadmapsRoadmapIdGet>>, TError = HTTPValidationError>(
 roadmapId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof readRoadmapApiV1RoadmapsRoadmapIdGet>>, TError, TData>>, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary Read Roadmap
 */

export function useReadRoadmapApiV1RoadmapsRoadmapIdGet<TData = Awaited<ReturnType<typeof readRoadmapApiV1RoadmapsRoadmapIdGet>>, TError = HTTPValidationError>(
 roadmapId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof readRoadmapApiV1RoadmapsRoadmapIdGet>>, TError, TData>>, }
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getReadRoadmapApiV1RoadmapsRoadmapIdGetQueryOptions(roadmapId,options)

  const query = useQuery(queryOptions , queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



/**
 * 特定のロードマップを更新する
 * @summary Update Roadmap Endpoint
 */
export const updateRoadmapEndpointApiV1RoadmapsRoadmapIdPut = (
    roadmapId: string,
    roadmapUpdateRequest: RoadmapUpdateRequest,
 ) => {
      
      
      return customInstance<RoadmapDetailApiResponse>(
      {url: `/api/v1/roadmaps/${roadmapId}`, method: 'PUT',
      headers: {'Content-Type': 'application/json', },
      data: roadmapUpdateRequest
    },
      );
    }
  


export const getUpdateRoadmapEndpointApiV1RoadmapsRoadmapIdPutMutationOptions = <TError = HTTPValidationError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof updateRoadmapEndpointApiV1RoadmapsRoadmapIdPut>>, TError,{roadmapId: string;data: RoadmapUpdateRequest}, TContext>, }
): UseMutationOptions<Awaited<ReturnType<typeof updateRoadmapEndpointApiV1RoadmapsRoadmapIdPut>>, TError,{roadmapId: string;data: RoadmapUpdateRequest}, TContext> => {
    
const mutationKey = ['updateRoadmapEndpointApiV1RoadmapsRoadmapIdPut'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof updateRoadmapEndpointApiV1RoadmapsRoadmapIdPut>>, {roadmapId: string;data: RoadmapUpdateRequest}> = (props) => {
          const {roadmapId,data} = props ?? {};

          return  updateRoadmapEndpointApiV1RoadmapsRoadmapIdPut(roadmapId,data,)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type UpdateRoadmapEndpointApiV1RoadmapsRoadmapIdPutMutationResult = NonNullable<Awaited<ReturnType<typeof updateRoadmapEndpointApiV1RoadmapsRoadmapIdPut>>>
    export type UpdateRoadmapEndpointApiV1RoadmapsRoadmapIdPutMutationBody = RoadmapUpdateRequest
    export type UpdateRoadmapEndpointApiV1RoadmapsRoadmapIdPutMutationError = HTTPValidationError

    /**
 * @summary Update Roadmap Endpoint
 */
export const useUpdateRoadmapEndpointApiV1RoadmapsRoadmapIdPut = <TError = HTTPValidationError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof updateRoadmapEndpointApiV1RoadmapsRoadmapIdPut>>, TError,{roadmapId: string;data: RoadmapUpdateRequest}, TContext>, }
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof updateRoadmapEndpointApiV1RoadmapsRoadmapIdPut>>,
        TError,
        {roadmapId: string;data: RoadmapUpdateRequest},
        TContext
      > => {

      const mutationOptions = getUpdateRoadmapEndpointApiV1RoadmapsRoadmapIdPutMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    /**
 * 特定のロードマップを削除する
 * @summary Delete Roadmap Endpoint
 */
export const deleteRoadmapEndpointApiV1RoadmapsRoadmapIdDelete = (
    roadmapId: string,
 ) => {
      
      
      return customInstance<void>(
      {url: `/api/v1/roadmaps/${roadmapId}`, method: 'DELETE'
    },
      );
    }
  


export const getDeleteRoadmapEndpointApiV1RoadmapsRoadmapIdDeleteMutationOptions = <TError = HTTPValidationError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof deleteRoadmapEndpointApiV1RoadmapsRoadmapIdDelete>>, TError,{roadmapId: string}, TContext>, }
): UseMutationOptions<Awaited<ReturnType<typeof deleteRoadmapEndpointApiV1RoadmapsRoadmapIdDelete>>, TError,{roadmapId: string}, TContext> => {
    
const mutationKey = ['deleteRoadmapEndpointApiV1RoadmapsRoadmapIdDelete'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof deleteRoadmapEndpointApiV1RoadmapsRoadmapIdDelete>>, {roadmapId: string}> = (props) => {
          const {roadmapId} = props ?? {};

          return  deleteRoadmapEndpointApiV1RoadmapsRoadmapIdDelete(roadmapId,)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type DeleteRoadmapEndpointApiV1RoadmapsRoadmapIdDeleteMutationResult = NonNullable<Awaited<ReturnType<typeof deleteRoadmapEndpointApiV1RoadmapsRoadmapIdDelete>>>
    
    export type DeleteRoadmapEndpointApiV1RoadmapsRoadmapIdDeleteMutationError = HTTPValidationError

    /**
 * @summary Delete Roadmap Endpoint
 */
export const useDeleteRoadmapEndpointApiV1RoadmapsRoadmapIdDelete = <TError = HTTPValidationError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof deleteRoadmapEndpointApiV1RoadmapsRoadmapIdDelete>>, TError,{roadmapId: string}, TContext>, }
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof deleteRoadmapEndpointApiV1RoadmapsRoadmapIdDelete>>,
        TError,
        {roadmapId: string},
        TContext
      > => {

      const mutationOptions = getDeleteRoadmapEndpointApiV1RoadmapsRoadmapIdDeleteMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    /**
 * 特定のテーマに関連するすべてのロードマップバージョンを取得する
 * @summary Read Roadmap Versions
 */
export const readRoadmapVersionsApiV1ThemesThemeIdRoadmapsVersionsGet = (
    themeId: string,
 signal?: AbortSignal
) => {
      
      
      return customInstance<RoadmapVersionListResponse>(
      {url: `/api/v1/themes/${themeId}/roadmaps/versions`, method: 'GET', signal
    },
      );
    }
  

export const getReadRoadmapVersionsApiV1ThemesThemeIdRoadmapsVersionsGetQueryKey = (themeId: string,) => {
    return [`/api/v1/themes/${themeId}/roadmaps/versions`] as const;
    }

    
export const getReadRoadmapVersionsApiV1ThemesThemeIdRoadmapsVersionsGetQueryOptions = <TData = Awaited<ReturnType<typeof readRoadmapVersionsApiV1ThemesThemeIdRoadmapsVersionsGet>>, TError = HTTPValidationError>(themeId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof readRoadmapVersionsApiV1ThemesThemeIdRoadmapsVersionsGet>>, TError, TData>>, }
) => {

const {query: queryOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getReadRoadmapVersionsApiV1ThemesThemeIdRoadmapsVersionsGetQueryKey(themeId);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof readRoadmapVersionsApiV1ThemesThemeIdRoadmapsVersionsGet>>> = ({ signal }) => readRoadmapVersionsApiV1ThemesThemeIdRoadmapsVersionsGet(themeId, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(themeId), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof readRoadmapVersionsApiV1ThemesThemeIdRoadmapsVersionsGet>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type ReadRoadmapVersionsApiV1ThemesThemeIdRoadmapsVersionsGetQueryResult = NonNullable<Awaited<ReturnType<typeof readRoadmapVersionsApiV1ThemesThemeIdRoadmapsVersionsGet>>>
export type ReadRoadmapVersionsApiV1ThemesThemeIdRoadmapsVersionsGetQueryError = HTTPValidationError


export function useReadRoadmapVersionsApiV1ThemesThemeIdRoadmapsVersionsGet<TData = Awaited<ReturnType<typeof readRoadmapVersionsApiV1ThemesThemeIdRoadmapsVersionsGet>>, TError = HTTPValidationError>(
 themeId: string, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof readRoadmapVersionsApiV1ThemesThemeIdRoadmapsVersionsGet>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof readRoadmapVersionsApiV1ThemesThemeIdRoadmapsVersionsGet>>,
          TError,
          Awaited<ReturnType<typeof readRoadmapVersionsApiV1ThemesThemeIdRoadmapsVersionsGet>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useReadRoadmapVersionsApiV1ThemesThemeIdRoadmapsVersionsGet<TData = Awaited<ReturnType<typeof readRoadmapVersionsApiV1ThemesThemeIdRoadmapsVersionsGet>>, TError = HTTPValidationError>(
 themeId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof readRoadmapVersionsApiV1ThemesThemeIdRoadmapsVersionsGet>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof readRoadmapVersionsApiV1ThemesThemeIdRoadmapsVersionsGet>>,
          TError,
          Awaited<ReturnType<typeof readRoadmapVersionsApiV1ThemesThemeIdRoadmapsVersionsGet>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useReadRoadmapVersionsApiV1ThemesThemeIdRoadmapsVersionsGet<TData = Awaited<ReturnType<typeof readRoadmapVersionsApiV1ThemesThemeIdRoadmapsVersionsGet>>, TError = HTTPValidationError>(
 themeId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof readRoadmapVersionsApiV1ThemesThemeIdRoadmapsVersionsGet>>, TError, TData>>, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary Read Roadmap Versions
 */

export function useReadRoadmapVersionsApiV1ThemesThemeIdRoadmapsVersionsGet<TData = Awaited<ReturnType<typeof readRoadmapVersionsApiV1ThemesThemeIdRoadmapsVersionsGet>>, TError = HTTPValidationError>(
 themeId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof readRoadmapVersionsApiV1ThemesThemeIdRoadmapsVersionsGet>>, TError, TData>>, }
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getReadRoadmapVersionsApiV1ThemesThemeIdRoadmapsVersionsGetQueryOptions(themeId,options)

  const query = useQuery(queryOptions , queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



/**
 * 特定のロードマップを公開状態にする
 * @summary Publish Roadmap Endpoint
 */
export const publishRoadmapEndpointApiV1RoadmapsRoadmapIdPublishPost = (
    roadmapId: string,
 signal?: AbortSignal
) => {
      
      
      return customInstance<RoadmapDetailApiResponse>(
      {url: `/api/v1/roadmaps/${roadmapId}/publish`, method: 'POST', signal
    },
      );
    }
  


export const getPublishRoadmapEndpointApiV1RoadmapsRoadmapIdPublishPostMutationOptions = <TError = HTTPValidationError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof publishRoadmapEndpointApiV1RoadmapsRoadmapIdPublishPost>>, TError,{roadmapId: string}, TContext>, }
): UseMutationOptions<Awaited<ReturnType<typeof publishRoadmapEndpointApiV1RoadmapsRoadmapIdPublishPost>>, TError,{roadmapId: string}, TContext> => {
    
const mutationKey = ['publishRoadmapEndpointApiV1RoadmapsRoadmapIdPublishPost'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof publishRoadmapEndpointApiV1RoadmapsRoadmapIdPublishPost>>, {roadmapId: string}> = (props) => {
          const {roadmapId} = props ?? {};

          return  publishRoadmapEndpointApiV1RoadmapsRoadmapIdPublishPost(roadmapId,)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type PublishRoadmapEndpointApiV1RoadmapsRoadmapIdPublishPostMutationResult = NonNullable<Awaited<ReturnType<typeof publishRoadmapEndpointApiV1RoadmapsRoadmapIdPublishPost>>>
    
    export type PublishRoadmapEndpointApiV1RoadmapsRoadmapIdPublishPostMutationError = HTTPValidationError

    /**
 * @summary Publish Roadmap Endpoint
 */
export const usePublishRoadmapEndpointApiV1RoadmapsRoadmapIdPublishPost = <TError = HTTPValidationError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof publishRoadmapEndpointApiV1RoadmapsRoadmapIdPublishPost>>, TError,{roadmapId: string}, TContext>, }
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof publishRoadmapEndpointApiV1RoadmapsRoadmapIdPublishPost>>,
        TError,
        {roadmapId: string},
        TContext
      > => {

      const mutationOptions = getPublishRoadmapEndpointApiV1RoadmapsRoadmapIdPublishPostMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    /**
 * 既存のロードマップから新しいバージョンを作成する
 * @summary Create New Version Endpoint
 */
export const createNewVersionEndpointApiV1RoadmapsRoadmapIdNewVersionPost = (
    roadmapId: string,
    params: CreateNewVersionEndpointApiV1RoadmapsRoadmapIdNewVersionPostParams,
 signal?: AbortSignal
) => {
      
      
      return customInstance<RoadmapDetailApiResponse>(
      {url: `/api/v1/roadmaps/${roadmapId}/new-version`, method: 'POST',
        params, signal
    },
      );
    }
  


export const getCreateNewVersionEndpointApiV1RoadmapsRoadmapIdNewVersionPostMutationOptions = <TError = HTTPValidationError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof createNewVersionEndpointApiV1RoadmapsRoadmapIdNewVersionPost>>, TError,{roadmapId: string;params: CreateNewVersionEndpointApiV1RoadmapsRoadmapIdNewVersionPostParams}, TContext>, }
): UseMutationOptions<Awaited<ReturnType<typeof createNewVersionEndpointApiV1RoadmapsRoadmapIdNewVersionPost>>, TError,{roadmapId: string;params: CreateNewVersionEndpointApiV1RoadmapsRoadmapIdNewVersionPostParams}, TContext> => {
    
const mutationKey = ['createNewVersionEndpointApiV1RoadmapsRoadmapIdNewVersionPost'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof createNewVersionEndpointApiV1RoadmapsRoadmapIdNewVersionPost>>, {roadmapId: string;params: CreateNewVersionEndpointApiV1RoadmapsRoadmapIdNewVersionPostParams}> = (props) => {
          const {roadmapId,params} = props ?? {};

          return  createNewVersionEndpointApiV1RoadmapsRoadmapIdNewVersionPost(roadmapId,params,)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type CreateNewVersionEndpointApiV1RoadmapsRoadmapIdNewVersionPostMutationResult = NonNullable<Awaited<ReturnType<typeof createNewVersionEndpointApiV1RoadmapsRoadmapIdNewVersionPost>>>
    
    export type CreateNewVersionEndpointApiV1RoadmapsRoadmapIdNewVersionPostMutationError = HTTPValidationError

    /**
 * @summary Create New Version Endpoint
 */
export const useCreateNewVersionEndpointApiV1RoadmapsRoadmapIdNewVersionPost = <TError = HTTPValidationError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof createNewVersionEndpointApiV1RoadmapsRoadmapIdNewVersionPost>>, TError,{roadmapId: string;params: CreateNewVersionEndpointApiV1RoadmapsRoadmapIdNewVersionPostParams}, TContext>, }
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof createNewVersionEndpointApiV1RoadmapsRoadmapIdNewVersionPost>>,
        TError,
        {roadmapId: string;params: CreateNewVersionEndpointApiV1RoadmapsRoadmapIdNewVersionPostParams},
        TContext
      > => {

      const mutationOptions = getCreateNewVersionEndpointApiV1RoadmapsRoadmapIdNewVersionPostMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    /**
 * 特定のロードマップのノード一覧を取得する
 * @summary Read Roadmap Nodes
 */
export const readRoadmapNodesApiV1RoadmapsRoadmapIdNodesGet = (
    roadmapId: string,
 signal?: AbortSignal
) => {
      
      
      return customInstance<RoadmapNodeResponse[]>(
      {url: `/api/v1/roadmaps/${roadmapId}/nodes`, method: 'GET', signal
    },
      );
    }
  

export const getReadRoadmapNodesApiV1RoadmapsRoadmapIdNodesGetQueryKey = (roadmapId: string,) => {
    return [`/api/v1/roadmaps/${roadmapId}/nodes`] as const;
    }

    
export const getReadRoadmapNodesApiV1RoadmapsRoadmapIdNodesGetQueryOptions = <TData = Awaited<ReturnType<typeof readRoadmapNodesApiV1RoadmapsRoadmapIdNodesGet>>, TError = HTTPValidationError>(roadmapId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof readRoadmapNodesApiV1RoadmapsRoadmapIdNodesGet>>, TError, TData>>, }
) => {

const {query: queryOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getReadRoadmapNodesApiV1RoadmapsRoadmapIdNodesGetQueryKey(roadmapId);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof readRoadmapNodesApiV1RoadmapsRoadmapIdNodesGet>>> = ({ signal }) => readRoadmapNodesApiV1RoadmapsRoadmapIdNodesGet(roadmapId, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(roadmapId), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof readRoadmapNodesApiV1RoadmapsRoadmapIdNodesGet>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type ReadRoadmapNodesApiV1RoadmapsRoadmapIdNodesGetQueryResult = NonNullable<Awaited<ReturnType<typeof readRoadmapNodesApiV1RoadmapsRoadmapIdNodesGet>>>
export type ReadRoadmapNodesApiV1RoadmapsRoadmapIdNodesGetQueryError = HTTPValidationError


export function useReadRoadmapNodesApiV1RoadmapsRoadmapIdNodesGet<TData = Awaited<ReturnType<typeof readRoadmapNodesApiV1RoadmapsRoadmapIdNodesGet>>, TError = HTTPValidationError>(
 roadmapId: string, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof readRoadmapNodesApiV1RoadmapsRoadmapIdNodesGet>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof readRoadmapNodesApiV1RoadmapsRoadmapIdNodesGet>>,
          TError,
          Awaited<ReturnType<typeof readRoadmapNodesApiV1RoadmapsRoadmapIdNodesGet>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useReadRoadmapNodesApiV1RoadmapsRoadmapIdNodesGet<TData = Awaited<ReturnType<typeof readRoadmapNodesApiV1RoadmapsRoadmapIdNodesGet>>, TError = HTTPValidationError>(
 roadmapId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof readRoadmapNodesApiV1RoadmapsRoadmapIdNodesGet>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof readRoadmapNodesApiV1RoadmapsRoadmapIdNodesGet>>,
          TError,
          Awaited<ReturnType<typeof readRoadmapNodesApiV1RoadmapsRoadmapIdNodesGet>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useReadRoadmapNodesApiV1RoadmapsRoadmapIdNodesGet<TData = Awaited<ReturnType<typeof readRoadmapNodesApiV1RoadmapsRoadmapIdNodesGet>>, TError = HTTPValidationError>(
 roadmapId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof readRoadmapNodesApiV1RoadmapsRoadmapIdNodesGet>>, TError, TData>>, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary Read Roadmap Nodes
 */

export function useReadRoadmapNodesApiV1RoadmapsRoadmapIdNodesGet<TData = Awaited<ReturnType<typeof readRoadmapNodesApiV1RoadmapsRoadmapIdNodesGet>>, TError = HTTPValidationError>(
 roadmapId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof readRoadmapNodesApiV1RoadmapsRoadmapIdNodesGet>>, TError, TData>>, }
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getReadRoadmapNodesApiV1RoadmapsRoadmapIdNodesGetQueryOptions(roadmapId,options)

  const query = useQuery(queryOptions , queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



/**
 * 新しいロードマップノードを作成する
 * @summary Create Roadmap Node Endpoint
 */
export const createRoadmapNodeEndpointApiV1RoadmapsNodesPost = (
    roadmapNodeCreateRequest: RoadmapNodeCreateRequest,
 signal?: AbortSignal
) => {
      
      
      return customInstance<RoadmapNodeResponse>(
      {url: `/api/v1/roadmaps/nodes`, method: 'POST',
      headers: {'Content-Type': 'application/json', },
      data: roadmapNodeCreateRequest, signal
    },
      );
    }
  


export const getCreateRoadmapNodeEndpointApiV1RoadmapsNodesPostMutationOptions = <TError = HTTPValidationError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof createRoadmapNodeEndpointApiV1RoadmapsNodesPost>>, TError,{data: RoadmapNodeCreateRequest}, TContext>, }
): UseMutationOptions<Awaited<ReturnType<typeof createRoadmapNodeEndpointApiV1RoadmapsNodesPost>>, TError,{data: RoadmapNodeCreateRequest}, TContext> => {
    
const mutationKey = ['createRoadmapNodeEndpointApiV1RoadmapsNodesPost'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof createRoadmapNodeEndpointApiV1RoadmapsNodesPost>>, {data: RoadmapNodeCreateRequest}> = (props) => {
          const {data} = props ?? {};

          return  createRoadmapNodeEndpointApiV1RoadmapsNodesPost(data,)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type CreateRoadmapNodeEndpointApiV1RoadmapsNodesPostMutationResult = NonNullable<Awaited<ReturnType<typeof createRoadmapNodeEndpointApiV1RoadmapsNodesPost>>>
    export type CreateRoadmapNodeEndpointApiV1RoadmapsNodesPostMutationBody = RoadmapNodeCreateRequest
    export type CreateRoadmapNodeEndpointApiV1RoadmapsNodesPostMutationError = HTTPValidationError

    /**
 * @summary Create Roadmap Node Endpoint
 */
export const useCreateRoadmapNodeEndpointApiV1RoadmapsNodesPost = <TError = HTTPValidationError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof createRoadmapNodeEndpointApiV1RoadmapsNodesPost>>, TError,{data: RoadmapNodeCreateRequest}, TContext>, }
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof createRoadmapNodeEndpointApiV1RoadmapsNodesPost>>,
        TError,
        {data: RoadmapNodeCreateRequest},
        TContext
      > => {

      const mutationOptions = getCreateRoadmapNodeEndpointApiV1RoadmapsNodesPostMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    /**
 * 特定のロードマップノードを更新する
 * @summary Update Roadmap Node Endpoint
 */
export const updateRoadmapNodeEndpointApiV1RoadmapsNodesNodeIdPut = (
    nodeId: string,
    roadmapNodeUpdateRequest: RoadmapNodeUpdateRequest,
 ) => {
      
      
      return customInstance<RoadmapNodeResponse>(
      {url: `/api/v1/roadmaps/nodes/${nodeId}`, method: 'PUT',
      headers: {'Content-Type': 'application/json', },
      data: roadmapNodeUpdateRequest
    },
      );
    }
  


export const getUpdateRoadmapNodeEndpointApiV1RoadmapsNodesNodeIdPutMutationOptions = <TError = HTTPValidationError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof updateRoadmapNodeEndpointApiV1RoadmapsNodesNodeIdPut>>, TError,{nodeId: string;data: RoadmapNodeUpdateRequest}, TContext>, }
): UseMutationOptions<Awaited<ReturnType<typeof updateRoadmapNodeEndpointApiV1RoadmapsNodesNodeIdPut>>, TError,{nodeId: string;data: RoadmapNodeUpdateRequest}, TContext> => {
    
const mutationKey = ['updateRoadmapNodeEndpointApiV1RoadmapsNodesNodeIdPut'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof updateRoadmapNodeEndpointApiV1RoadmapsNodesNodeIdPut>>, {nodeId: string;data: RoadmapNodeUpdateRequest}> = (props) => {
          const {nodeId,data} = props ?? {};

          return  updateRoadmapNodeEndpointApiV1RoadmapsNodesNodeIdPut(nodeId,data,)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type UpdateRoadmapNodeEndpointApiV1RoadmapsNodesNodeIdPutMutationResult = NonNullable<Awaited<ReturnType<typeof updateRoadmapNodeEndpointApiV1RoadmapsNodesNodeIdPut>>>
    export type UpdateRoadmapNodeEndpointApiV1RoadmapsNodesNodeIdPutMutationBody = RoadmapNodeUpdateRequest
    export type UpdateRoadmapNodeEndpointApiV1RoadmapsNodesNodeIdPutMutationError = HTTPValidationError

    /**
 * @summary Update Roadmap Node Endpoint
 */
export const useUpdateRoadmapNodeEndpointApiV1RoadmapsNodesNodeIdPut = <TError = HTTPValidationError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof updateRoadmapNodeEndpointApiV1RoadmapsNodesNodeIdPut>>, TError,{nodeId: string;data: RoadmapNodeUpdateRequest}, TContext>, }
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof updateRoadmapNodeEndpointApiV1RoadmapsNodesNodeIdPut>>,
        TError,
        {nodeId: string;data: RoadmapNodeUpdateRequest},
        TContext
      > => {

      const mutationOptions = getUpdateRoadmapNodeEndpointApiV1RoadmapsNodesNodeIdPutMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    /**
 * 特定のロードマップノードを削除する
 * @summary Delete Roadmap Node Endpoint
 */
export const deleteRoadmapNodeEndpointApiV1RoadmapsNodesNodeIdDelete = (
    nodeId: string,
 ) => {
      
      
      return customInstance<void>(
      {url: `/api/v1/roadmaps/nodes/${nodeId}`, method: 'DELETE'
    },
      );
    }
  


export const getDeleteRoadmapNodeEndpointApiV1RoadmapsNodesNodeIdDeleteMutationOptions = <TError = HTTPValidationError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof deleteRoadmapNodeEndpointApiV1RoadmapsNodesNodeIdDelete>>, TError,{nodeId: string}, TContext>, }
): UseMutationOptions<Awaited<ReturnType<typeof deleteRoadmapNodeEndpointApiV1RoadmapsNodesNodeIdDelete>>, TError,{nodeId: string}, TContext> => {
    
const mutationKey = ['deleteRoadmapNodeEndpointApiV1RoadmapsNodesNodeIdDelete'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof deleteRoadmapNodeEndpointApiV1RoadmapsNodesNodeIdDelete>>, {nodeId: string}> = (props) => {
          const {nodeId} = props ?? {};

          return  deleteRoadmapNodeEndpointApiV1RoadmapsNodesNodeIdDelete(nodeId,)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type DeleteRoadmapNodeEndpointApiV1RoadmapsNodesNodeIdDeleteMutationResult = NonNullable<Awaited<ReturnType<typeof deleteRoadmapNodeEndpointApiV1RoadmapsNodesNodeIdDelete>>>
    
    export type DeleteRoadmapNodeEndpointApiV1RoadmapsNodesNodeIdDeleteMutationError = HTTPValidationError

    /**
 * @summary Delete Roadmap Node Endpoint
 */
export const useDeleteRoadmapNodeEndpointApiV1RoadmapsNodesNodeIdDelete = <TError = HTTPValidationError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof deleteRoadmapNodeEndpointApiV1RoadmapsNodesNodeIdDelete>>, TError,{nodeId: string}, TContext>, }
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof deleteRoadmapNodeEndpointApiV1RoadmapsNodesNodeIdDelete>>,
        TError,
        {nodeId: string},
        TContext
      > => {

      const mutationOptions = getDeleteRoadmapNodeEndpointApiV1RoadmapsNodesNodeIdDeleteMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    /**
 * 特定のロードマップのエッジ一覧を取得する
 * @summary Read Roadmap Edges
 */
export const readRoadmapEdgesApiV1RoadmapsRoadmapIdEdgesGet = (
    roadmapId: string,
 signal?: AbortSignal
) => {
      
      
      return customInstance<RoadmapEdgeResponse[]>(
      {url: `/api/v1/roadmaps/${roadmapId}/edges`, method: 'GET', signal
    },
      );
    }
  

export const getReadRoadmapEdgesApiV1RoadmapsRoadmapIdEdgesGetQueryKey = (roadmapId: string,) => {
    return [`/api/v1/roadmaps/${roadmapId}/edges`] as const;
    }

    
export const getReadRoadmapEdgesApiV1RoadmapsRoadmapIdEdgesGetQueryOptions = <TData = Awaited<ReturnType<typeof readRoadmapEdgesApiV1RoadmapsRoadmapIdEdgesGet>>, TError = HTTPValidationError>(roadmapId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof readRoadmapEdgesApiV1RoadmapsRoadmapIdEdgesGet>>, TError, TData>>, }
) => {

const {query: queryOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getReadRoadmapEdgesApiV1RoadmapsRoadmapIdEdgesGetQueryKey(roadmapId);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof readRoadmapEdgesApiV1RoadmapsRoadmapIdEdgesGet>>> = ({ signal }) => readRoadmapEdgesApiV1RoadmapsRoadmapIdEdgesGet(roadmapId, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(roadmapId), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof readRoadmapEdgesApiV1RoadmapsRoadmapIdEdgesGet>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type ReadRoadmapEdgesApiV1RoadmapsRoadmapIdEdgesGetQueryResult = NonNullable<Awaited<ReturnType<typeof readRoadmapEdgesApiV1RoadmapsRoadmapIdEdgesGet>>>
export type ReadRoadmapEdgesApiV1RoadmapsRoadmapIdEdgesGetQueryError = HTTPValidationError


export function useReadRoadmapEdgesApiV1RoadmapsRoadmapIdEdgesGet<TData = Awaited<ReturnType<typeof readRoadmapEdgesApiV1RoadmapsRoadmapIdEdgesGet>>, TError = HTTPValidationError>(
 roadmapId: string, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof readRoadmapEdgesApiV1RoadmapsRoadmapIdEdgesGet>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof readRoadmapEdgesApiV1RoadmapsRoadmapIdEdgesGet>>,
          TError,
          Awaited<ReturnType<typeof readRoadmapEdgesApiV1RoadmapsRoadmapIdEdgesGet>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useReadRoadmapEdgesApiV1RoadmapsRoadmapIdEdgesGet<TData = Awaited<ReturnType<typeof readRoadmapEdgesApiV1RoadmapsRoadmapIdEdgesGet>>, TError = HTTPValidationError>(
 roadmapId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof readRoadmapEdgesApiV1RoadmapsRoadmapIdEdgesGet>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof readRoadmapEdgesApiV1RoadmapsRoadmapIdEdgesGet>>,
          TError,
          Awaited<ReturnType<typeof readRoadmapEdgesApiV1RoadmapsRoadmapIdEdgesGet>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useReadRoadmapEdgesApiV1RoadmapsRoadmapIdEdgesGet<TData = Awaited<ReturnType<typeof readRoadmapEdgesApiV1RoadmapsRoadmapIdEdgesGet>>, TError = HTTPValidationError>(
 roadmapId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof readRoadmapEdgesApiV1RoadmapsRoadmapIdEdgesGet>>, TError, TData>>, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary Read Roadmap Edges
 */

export function useReadRoadmapEdgesApiV1RoadmapsRoadmapIdEdgesGet<TData = Awaited<ReturnType<typeof readRoadmapEdgesApiV1RoadmapsRoadmapIdEdgesGet>>, TError = HTTPValidationError>(
 roadmapId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof readRoadmapEdgesApiV1RoadmapsRoadmapIdEdgesGet>>, TError, TData>>, }
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getReadRoadmapEdgesApiV1RoadmapsRoadmapIdEdgesGetQueryOptions(roadmapId,options)

  const query = useQuery(queryOptions , queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



/**
 * 新しいロードマップエッジを作成する
 * @summary Create Roadmap Edge Endpoint
 */
export const createRoadmapEdgeEndpointApiV1RoadmapsEdgesPost = (
    roadmapEdgeCreateRequest: RoadmapEdgeCreateRequest,
 signal?: AbortSignal
) => {
      
      
      return customInstance<RoadmapEdgeResponse>(
      {url: `/api/v1/roadmaps/edges`, method: 'POST',
      headers: {'Content-Type': 'application/json', },
      data: roadmapEdgeCreateRequest, signal
    },
      );
    }
  


export const getCreateRoadmapEdgeEndpointApiV1RoadmapsEdgesPostMutationOptions = <TError = HTTPValidationError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof createRoadmapEdgeEndpointApiV1RoadmapsEdgesPost>>, TError,{data: RoadmapEdgeCreateRequest}, TContext>, }
): UseMutationOptions<Awaited<ReturnType<typeof createRoadmapEdgeEndpointApiV1RoadmapsEdgesPost>>, TError,{data: RoadmapEdgeCreateRequest}, TContext> => {
    
const mutationKey = ['createRoadmapEdgeEndpointApiV1RoadmapsEdgesPost'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof createRoadmapEdgeEndpointApiV1RoadmapsEdgesPost>>, {data: RoadmapEdgeCreateRequest}> = (props) => {
          const {data} = props ?? {};

          return  createRoadmapEdgeEndpointApiV1RoadmapsEdgesPost(data,)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type CreateRoadmapEdgeEndpointApiV1RoadmapsEdgesPostMutationResult = NonNullable<Awaited<ReturnType<typeof createRoadmapEdgeEndpointApiV1RoadmapsEdgesPost>>>
    export type CreateRoadmapEdgeEndpointApiV1RoadmapsEdgesPostMutationBody = RoadmapEdgeCreateRequest
    export type CreateRoadmapEdgeEndpointApiV1RoadmapsEdgesPostMutationError = HTTPValidationError

    /**
 * @summary Create Roadmap Edge Endpoint
 */
export const useCreateRoadmapEdgeEndpointApiV1RoadmapsEdgesPost = <TError = HTTPValidationError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof createRoadmapEdgeEndpointApiV1RoadmapsEdgesPost>>, TError,{data: RoadmapEdgeCreateRequest}, TContext>, }
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof createRoadmapEdgeEndpointApiV1RoadmapsEdgesPost>>,
        TError,
        {data: RoadmapEdgeCreateRequest},
        TContext
      > => {

      const mutationOptions = getCreateRoadmapEdgeEndpointApiV1RoadmapsEdgesPostMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    /**
 * 特定のロードマップエッジを更新する
 * @summary Update Roadmap Edge Endpoint
 */
export const updateRoadmapEdgeEndpointApiV1RoadmapsEdgesEdgeIdPut = (
    edgeId: string,
    roadmapEdgeUpdateRequest: RoadmapEdgeUpdateRequest,
 ) => {
      
      
      return customInstance<RoadmapEdgeResponse>(
      {url: `/api/v1/roadmaps/edges/${edgeId}`, method: 'PUT',
      headers: {'Content-Type': 'application/json', },
      data: roadmapEdgeUpdateRequest
    },
      );
    }
  


export const getUpdateRoadmapEdgeEndpointApiV1RoadmapsEdgesEdgeIdPutMutationOptions = <TError = HTTPValidationError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof updateRoadmapEdgeEndpointApiV1RoadmapsEdgesEdgeIdPut>>, TError,{edgeId: string;data: RoadmapEdgeUpdateRequest}, TContext>, }
): UseMutationOptions<Awaited<ReturnType<typeof updateRoadmapEdgeEndpointApiV1RoadmapsEdgesEdgeIdPut>>, TError,{edgeId: string;data: RoadmapEdgeUpdateRequest}, TContext> => {
    
const mutationKey = ['updateRoadmapEdgeEndpointApiV1RoadmapsEdgesEdgeIdPut'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof updateRoadmapEdgeEndpointApiV1RoadmapsEdgesEdgeIdPut>>, {edgeId: string;data: RoadmapEdgeUpdateRequest}> = (props) => {
          const {edgeId,data} = props ?? {};

          return  updateRoadmapEdgeEndpointApiV1RoadmapsEdgesEdgeIdPut(edgeId,data,)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type UpdateRoadmapEdgeEndpointApiV1RoadmapsEdgesEdgeIdPutMutationResult = NonNullable<Awaited<ReturnType<typeof updateRoadmapEdgeEndpointApiV1RoadmapsEdgesEdgeIdPut>>>
    export type UpdateRoadmapEdgeEndpointApiV1RoadmapsEdgesEdgeIdPutMutationBody = RoadmapEdgeUpdateRequest
    export type UpdateRoadmapEdgeEndpointApiV1RoadmapsEdgesEdgeIdPutMutationError = HTTPValidationError

    /**
 * @summary Update Roadmap Edge Endpoint
 */
export const useUpdateRoadmapEdgeEndpointApiV1RoadmapsEdgesEdgeIdPut = <TError = HTTPValidationError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof updateRoadmapEdgeEndpointApiV1RoadmapsEdgesEdgeIdPut>>, TError,{edgeId: string;data: RoadmapEdgeUpdateRequest}, TContext>, }
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof updateRoadmapEdgeEndpointApiV1RoadmapsEdgesEdgeIdPut>>,
        TError,
        {edgeId: string;data: RoadmapEdgeUpdateRequest},
        TContext
      > => {

      const mutationOptions = getUpdateRoadmapEdgeEndpointApiV1RoadmapsEdgesEdgeIdPutMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    /**
 * 特定のロードマップエッジを削除する
 * @summary Delete Roadmap Edge Endpoint
 */
export const deleteRoadmapEdgeEndpointApiV1RoadmapsEdgesEdgeIdDelete = (
    edgeId: string,
 ) => {
      
      
      return customInstance<void>(
      {url: `/api/v1/roadmaps/edges/${edgeId}`, method: 'DELETE'
    },
      );
    }
  


export const getDeleteRoadmapEdgeEndpointApiV1RoadmapsEdgesEdgeIdDeleteMutationOptions = <TError = HTTPValidationError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof deleteRoadmapEdgeEndpointApiV1RoadmapsEdgesEdgeIdDelete>>, TError,{edgeId: string}, TContext>, }
): UseMutationOptions<Awaited<ReturnType<typeof deleteRoadmapEdgeEndpointApiV1RoadmapsEdgesEdgeIdDelete>>, TError,{edgeId: string}, TContext> => {
    
const mutationKey = ['deleteRoadmapEdgeEndpointApiV1RoadmapsEdgesEdgeIdDelete'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof deleteRoadmapEdgeEndpointApiV1RoadmapsEdgesEdgeIdDelete>>, {edgeId: string}> = (props) => {
          const {edgeId} = props ?? {};

          return  deleteRoadmapEdgeEndpointApiV1RoadmapsEdgesEdgeIdDelete(edgeId,)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type DeleteRoadmapEdgeEndpointApiV1RoadmapsEdgesEdgeIdDeleteMutationResult = NonNullable<Awaited<ReturnType<typeof deleteRoadmapEdgeEndpointApiV1RoadmapsEdgesEdgeIdDelete>>>
    
    export type DeleteRoadmapEdgeEndpointApiV1RoadmapsEdgesEdgeIdDeleteMutationError = HTTPValidationError

    /**
 * @summary Delete Roadmap Edge Endpoint
 */
export const useDeleteRoadmapEdgeEndpointApiV1RoadmapsEdgesEdgeIdDelete = <TError = HTTPValidationError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof deleteRoadmapEdgeEndpointApiV1RoadmapsEdgesEdgeIdDelete>>, TError,{edgeId: string}, TContext>, }
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof deleteRoadmapEdgeEndpointApiV1RoadmapsEdgesEdgeIdDelete>>,
        TError,
        {edgeId: string},
        TContext
      > => {

      const mutationOptions = getDeleteRoadmapEdgeEndpointApiV1RoadmapsEdgesEdgeIdDeleteMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    